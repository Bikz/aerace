contract BarrierOptions =

    record bet = {
        on_up : bool,
        amount : int
    }

    record market = {
        id : int,
        barrier_up : int,
        barrier_down : option(int),
        expiry : int,
        is_race : bool,
        status : string,
        total_up : int,
        total_down : int,
        bets : map(address, bet)
    }

    record state = {
        owner : address,
        market_counter : int,
        markets : map(int, market)
    }

    event MarketCreated(id : int, barrier_up : int, barrier_down : option(int), expiry : int, is_race : bool)
    event BetPlaced(id : int, bettor : address, on_up : bool, amount : int)
    event TouchedUp(id : int, price : int)
    event TouchedDown(id : int, price : int)
    event MarketExpired(id : int)
    event PayoutClaimed(id : int, account : address, payout : int)

    entrypoint init() = {
        owner = Call.caller,
        market_counter = 0,
        markets = {}
    }

    stateful entrypoint createMarket(barrierUp : int, barrierDown : option(int), duration : int, isRace : bool) =
        require(Call.caller == state.owner, "ERR_NOT_OWNER")
        require(barrierUp > 0, "ERR_INVALID_BARRIER_UP")
        require(duration > 0, "ERR_INVALID_DURATION")
        let has_barrier_down =
            switch(barrierDown)
                None => false
                Some(_) => true
        require((not isRace) or has_barrier_down, "ERR_BARRIER_DOWN_REQUIRED")
        let new_id = state.market_counter + 1
        let expiry = Chain.block_height + duration
        let new_market = {
            id = new_id,
            barrier_up = barrierUp,
            barrier_down = barrierDown,
            expiry = expiry,
            is_race = isRace,
            status = "open",
            total_up = 0,
            total_down = 0,
            bets = {}
        }
        let updated_markets = Map.insert(new_id, new_market, state.markets)
        put(state{ market_counter = new_id, markets = updated_markets })
        emit(MarketCreated(new_id, barrierUp, barrierDown, expiry, isRace))

    payable stateful entrypoint placeBet(id : int, onUp : bool) =
        let market = get_market(id)
        require(market.status == "open", "ERR_MARKET_CLOSED")
        require(Chain.block_height < market.expiry, "ERR_MARKET_EXPIRED")
        require(Call.value > 0, "ERR_ZERO_BET")
        let existing_bet = Map.lookup(Call.caller, market.bets)
        switch(existing_bet)
            None => ()
            Some(b) => require(b.on_up == onUp, "ERR_SWITCH_SIDE")
        let merged_amount =
            switch(existing_bet)
                None => Call.value
                Some(b) => b.amount + Call.value
        let updated_bet = {
            on_up = onUp,
            amount = merged_amount
        }
        let updated_bets = Map.insert(Call.caller, updated_bet, market.bets)
        let updated_market =
            if(onUp)
                market{ bets = updated_bets, total_up = market.total_up + Call.value }
            else
                market{ bets = updated_bets, total_down = market.total_down + Call.value }
        let updated_markets = Map.insert(id, updated_market, state.markets)
        put(state{ markets = updated_markets })
        emit(BetPlaced(id, Call.caller, onUp, Call.value))

    stateful entrypoint checkMarket(id : int, price : int) =
        require(Call.caller == state.owner, "ERR_NOT_OWNER")
        require(price >= 0, "ERR_INVALID_PRICE")
        let market = get_market(id)
        let updated_market = evaluate_market(market, price)
        if(updated_market.status != market.status)
            let updated_markets = Map.insert(id, updated_market, state.markets)
            put(state{ markets = updated_markets })

    payable stateful entrypoint claimPayout(id : int) =
        let market = get_market(id)
        require(market.status != "open", "ERR_MARKET_NOT_RESOLVED")
        let bet =
            switch(Map.lookup(Call.caller, market.bets))
                None => abort("ERR_NO_BET")
                Some(b) => b
        let winners_on_up =
            switch(market.status)
                "touched_up" => true
                "touched_down" => false
                "expired" => false
                _ => abort("ERR_UNSUPPORTED_STATUS")
        let is_winner = if(winners_on_up) bet.on_up else not bet.on_up
        require(is_winner, "ERR_NOT_WINNER")
        let total_pool = market.total_up + market.total_down
        let winning_total = if(winners_on_up) market.total_up else market.total_down
        require(winning_total > 0, "ERR_NO_WINNERS")
        let raw_payout = bet.amount * total_pool div winning_total
        let payout = apply_fee(raw_payout)
        require(payout > 0, "ERR_ZERO_PAYOUT")
        require(Chain.balance(Contract.address) >= payout, "ERR_CONTRACT_BALANCE")
        Chain.spend(Call.caller, payout)
        let cleaned_bets = Map.delete(Call.caller, market.bets)
        let updated_market = market{ bets = cleaned_bets }
        let updated_markets = Map.insert(id, updated_market, state.markets)
        put(state{ markets = updated_markets })
        emit(PayoutClaimed(id, Call.caller, payout))

    function apply_fee(amount : int) : int =
        let fee_ppm = 0
        amount - amount * fee_ppm div 1000000

    stateful function evaluate_market(market : market, price : int) : market =
        if(market.status != "open")
            market
        else
            let touched_up = price >= market.barrier_up
            let touched_down =
                if(market.is_race)
                    switch(market.barrier_down)
                        None => false
                        Some(b) => price <= b
                else
                    false
            if(touched_up)
                emit(TouchedUp(market.id, price))
                market{ status = "touched_up" }
            elif(touched_down)
                emit(TouchedDown(market.id, price))
                market{ status = "touched_down" }
            elif(Chain.block_height >= market.expiry)
                emit(MarketExpired(market.id))
                market{ status = "expired" }
            else
                market

    function get_market(id : int) : market =
        switch(Map.lookup(id, state.markets))
            None => abort("ERR_UNKNOWN_MARKET")
            Some(market) => market
