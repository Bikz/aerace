@compiler >= 6

contract BarrierOptions =

  type query_type = string
  type answer_type = int
  type price_oracle = oracle(query_type, answer_type)
  type price_query = oracle_query(query_type, answer_type)

  datatype market_status = StatusOpen | StatusTouchedUp | StatusTouchedDown | StatusExpired

  record bet =
    { on_up  : bool
    , amount : int }

  record market =
    { id           : int
    , asset        : string
    , barrier_up   : int
    , barrier_down : int
    , expiry       : int
    , is_race      : bool
    , status       : market_status
    , total_up     : int
    , total_down   : int
    , bets         : map(address, bet) }

  record state =
    { owner               : address
    , market_counter      : int
    , markets             : map(int, market)
    , oracle              : option(price_oracle)
    , oracle_fee          : int
    , oracle_query_ttl    : int
    , oracle_response_ttl : int
    , oracle_queries      : map(int, price_query)
    , rake_ppm            : int }

  datatype event =
    MarketCreatedEvent(int, int, int)
    | BetPlacedEvent(int, address, int)
    | TouchUpEvent(int, int)
    | TouchDownEvent(int, int)
    | MarketExpiredEvent(int)
    | PayoutClaimed(int, address, int)
    | OracleConfiguredEvent(int, int, int)
    | OraclePriceRequested(int, string)
    | OraclePriceConsumedEvent(int, int)

  entrypoint init() =
    { owner = Call.caller,
      market_counter = 0,
      markets = {},
      oracle = None,
      oracle_fee = 0,
      oracle_query_ttl = 0,
      oracle_response_ttl = 0,
      oracle_queries = {},
      rake_ppm = 20000 }

  stateful entrypoint configureOracle(oracleAddr : price_oracle, queryFee : int, queryTtl : int, responseTtl : int) =
    require(Call.caller == state.owner, "ERR_NOT_OWNER")
    require(queryFee > 0, "ERR_INVALID_ORACLE_FEE")
    require(queryTtl > 0, "ERR_INVALID_QUERY_TTL")
    require(responseTtl > 0, "ERR_INVALID_RESPONSE_TTL")
    put(state{ oracle = Some(oracleAddr),
               oracle_fee = queryFee,
               oracle_query_ttl = queryTtl,
               oracle_response_ttl = responseTtl,
               oracle_queries = {} })
    Chain.event(OracleConfiguredEvent(queryFee, queryTtl, responseTtl))

  stateful entrypoint setRake(rakePpm : int) =
    require(Call.caller == state.owner, "ERR_NOT_OWNER")
    require(rakePpm >= 0, "ERR_INVALID_RAKE")
    require(rakePpm =< 100000, "ERR_RAKE_TOO_HIGH")
    put(state{ rake_ppm = rakePpm })

  stateful entrypoint withdrawRake(amount : int) =
    require(Call.caller == state.owner, "ERR_NOT_OWNER")
    require(amount > 0, "ERR_INVALID_WITHDRAWAL")
    require(Chain.balance(Contract.address) >= amount, "ERR_INSUFFICIENT_CONTRACT_BALANCE")
    Chain.spend(Call.caller, amount)

  payable stateful entrypoint requestOraclePrice(id : int, payload : string) =
    require(Call.caller == state.owner, "ERR_NOT_OWNER")
    require(payload != "", "ERR_EMPTY_PAYLOAD")
    let market = getMarket(id)
    require(market.status == StatusOpen, "ERR_MARKET_CLOSED")
    require(Chain.block_height < market.expiry, "ERR_MARKET_EXPIRED")
    let oracle = getOracle()
    let fee_to_pay = state.oracle_fee
    require(Call.value >= fee_to_pay, "ERR_INSUFFICIENT_QUERY_FEE")
    require(state.oracle_query_ttl > 0, "ERR_ORACLE_NOT_CONFIGURED")
    require(state.oracle_response_ttl > 0, "ERR_ORACLE_NOT_CONFIGURED")
    switch(Map.lookup(id, state.oracle_queries))
      None => ()
      Some(_) => abort("ERR_QUERY_EXISTS")
    let query = Oracle.query(oracle, payload, fee_to_pay, RelativeTTL(state.oracle_query_ttl), RelativeTTL(state.oracle_response_ttl))
    put(state{ oracle_queries[id] = query })
    let excess = Call.value - fee_to_pay
    if(excess > 0)
      Chain.spend(Call.caller, excess)
    Chain.event(OraclePriceRequested(id, payload))

  stateful entrypoint checkMarketFromOracle(id : int) =
    require(Call.caller == state.owner, "ERR_NOT_OWNER")
    let oracle = getOracle()
    let query = getOracleQueryInternal(id)
    switch(Oracle.get_answer(oracle, query))
      None => abort("ERR_ORACLE_PENDING")
      Some(price) =>
        require(price >= 0, "ERR_INVALID_PRICE")
        settleMarketWithPrice(id, price, true)
        Chain.event(OraclePriceConsumedEvent(id, price))

  stateful entrypoint createMarket(asset : string, barrierUp : int, barrierDown : int, duration : int, raceMode : bool) =
    require(barrierUp > 0, "ERR_INVALID_BARRIER_UP")
    require(duration > 0, "ERR_INVALID_DURATION")
    if(raceMode)
      require(barrierDown > 0, "ERR_BARRIER_DOWN_REQUIRED")
    else
      ()
    let new_id = state.market_counter + 1
    let expiry = Chain.block_height + duration
    let new_market : market = { id = new_id,
                               asset = asset,
                               barrier_up = barrierUp,
                               barrier_down = barrierDown,
                               expiry = expiry,
                               is_race = raceMode,
                               status = StatusOpen,
                               total_up = 0,
                               total_down = 0,
                               bets = {} }
    put(state{ markets[new_id] = new_market })
    put(state{ market_counter = new_id })
    Chain.event(MarketCreatedEvent(new_id, barrierUp, expiry))

  payable stateful entrypoint placeBet(id : int, onUp : bool) =
    let market = getMarket(id)
    require(market.status == StatusOpen, "ERR_MARKET_CLOSED")
    require(Chain.block_height < market.expiry, "ERR_MARKET_EXPIRED")
    require(Call.value > 0, "ERR_ZERO_BET")
    let existing_bet = Map.lookup(Call.caller, market.bets)
    switch(existing_bet)
      None => ()
      Some(b) => require(b.on_up == onUp, "ERR_SWITCH_SIDE")
    let merged_amount =
      switch(existing_bet)
        None => Call.value
        Some(b) => b.amount + Call.value
    let updated_bet = { on_up = onUp, amount = merged_amount }
    let market_with_bet = market{ bets[Call.caller] = updated_bet }
    let updated_market =
      if(onUp)
        market_with_bet{ total_up = market.total_up + Call.value }
      else
        market_with_bet{ total_down = market.total_down + Call.value }
    put(state{ markets[id] = updated_market })
    Chain.event(BetPlacedEvent(id, Call.caller, Call.value))

  stateful entrypoint checkMarket(id : int, price : int) =
    require(Call.caller == state.owner, "ERR_NOT_OWNER")
    require(price >= 0, "ERR_INVALID_PRICE")
    settleMarketWithPrice(id, price, false)

  payable stateful entrypoint claimPayout(id : int) =
    let market = getMarket(id)
    require(market.status != StatusOpen, "ERR_MARKET_NOT_RESOLVED")
    let user_bet = getBetForCaller(market)
    let winners_on_up =
      switch(market.status)
        StatusTouchedUp => true
        StatusTouchedDown => false
        StatusExpired => false
        StatusOpen => abort("ERR_MARKET_NOT_RESOLVED")
    let is_winner =
      if(winners_on_up)
        user_bet.on_up
      else
        !user_bet.on_up
    require(is_winner, "ERR_NOT_WINNER")
    let total_pool = market.total_up + market.total_down
    let winning_total = if(winners_on_up) market.total_up else market.total_down
    require(winning_total > 0, "ERR_NO_WINNERS")
    let numerator = user_bet.amount * total_pool
    let raw_payout = numerator / winning_total
    let payout = applyFee(raw_payout)
    require(payout > 0, "ERR_ZERO_PAYOUT")
    require(Chain.balance(Contract.address) >= payout, "ERR_CONTRACT_BALANCE")
    Chain.spend(Call.caller, payout)
    let cleaned_bets = Map.delete(Call.caller, market.bets)
    let updated_market_after_claim = market{ bets = cleaned_bets }
    put(state{ markets[id] = updated_market_after_claim })
    Chain.event(PayoutClaimed(id, Call.caller, payout))

  stateful function settleMarketWithPrice(id : int, price : int, dropQuery : bool) =
    let market = getMarket(id)
    let updatedMarket = evaluateMarket(market, price)
    let updatedQueries =
      if(dropQuery)
        Map.delete(id, state.oracle_queries)
      else
        state.oracle_queries
    put(state{ markets[id] = updatedMarket })
    put(state{ oracle_queries = updatedQueries })

  function applyFee(amount : int) : int =
    amount - (amount * state.rake_ppm) / 1000000

  stateful function evaluateMarket(market : market, price : int) : market =
    switch(market.status)
      StatusOpen =>
        let touchedUp = price >= market.barrier_up
        let touchedDown =
          if(market.is_race)
            price =< market.barrier_down
          else
            false
        if(touchedUp)
          Chain.event(TouchUpEvent(market.id, price))
          market{ status = StatusTouchedUp }
        elif(touchedDown)
          Chain.event(TouchDownEvent(market.id, price))
          market{ status = StatusTouchedDown }
        elif(Chain.block_height >= market.expiry)
          Chain.event(MarketExpiredEvent(market.id))
          market{ status = StatusExpired }
        else
          market
      _ => market

  function getOracle() : price_oracle =
    switch(state.oracle)
      None => abort("ERR_ORACLE_NOT_CONFIGURED")
      Some(oracle) => oracle

  function getOracleQueryInternal(id : int) : price_query =
    switch(Map.lookup(id, state.oracle_queries))
      None => abort("ERR_QUERY_NOT_FOUND")
      Some(query) => query

  entrypoint getOracleQuery(id : int) : option(price_query) =
    Map.lookup(id, state.oracle_queries)

  entrypoint getMarketCounter() : int = state.market_counter

  entrypoint getRake() : int = state.rake_ppm

  entrypoint getMarketData(id : int) : market =
    getMarket(id)

  function getMarket(id : int) : market =
    switch(Map.lookup(id, state.markets))
      None => abort("ERR_UNKNOWN_MARKET")
      Some(m) => m

  function getBetForCaller(market : market) : bet =
    switch(Map.lookup(Call.caller, market.bets))
      None => abort("ERR_NO_BET")
      Some(b) => b
